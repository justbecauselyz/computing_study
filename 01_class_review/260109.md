# Graph RAG (Graph Retrieval-Augmented Generation)
## 1. 정의 (Definition)
기존 RAG가 단순히 "키워드가 비슷한 문장"을 찾아낸다면, Graph RAG는 문서 전체를 분석해 엔티티(Entity, 개체)와 관계(Relation)를 그래프 구조로 만들고, 이를 탐색해서 더 깊이 있는 답변을 생성함
>지식 그래프(Knowledge Graph)와 LLM을 결합하여, 데이터 간의 복잡한 관계와 문맥까지 파악해 답변하는 고도화된 검색 기술
## 2. 등장 배경
- 기존 Vector RAG의 한계: 문서를 잘게 쪼개서 저장하다 보니, 문서 전체를 관통하는 주제나, 멀리 떨어져 있는정보 간의 연결고리를 놓침
- Graph RAG의 해결책
    - 데이터를 점과 선으로 연결된 그래프로 저장
    - A 문서와 B 문서에 흩어진 정보를 연결해서 전체적인 그림을 볼 수있음
## 3. 작동 원리
1. **지식 추출 (Source to Graph)**: LLM을 사용해 문서에서 중요한 명사(Entity)와 그들 사이의 관계(Relationship)를 추출함.
2. **그래프 구축 (Graph Indexing)**: 추출한 정보를 그래프 데이터베이스(Neo4j 등)나 구조화된 형태로 저장. 비슷한 무리끼리 묶는 커뮤니티 감지(Community Detection) 알고리즘을 수행하기도 함.
3. **검색 및 답변 (Query & Answer)**: 질문이 들어오면 관련 엔티티를 찾고, 그와 연결된 '관계'들을 따라가며 정보를 수집(Traversal)해서 LLM에게 넘겨줌.
## 4. 기존 RAG vs Graph RAG 비교
 구분 | 기존 RAG | Graph RAG |
|------|------|------|
| 데이터 구조 | 벡터(Vector) 임베딩 | 지식 그래프 (Nodes & Edges) |
| 검색 방식 | 유사도 검색 (Similarity Search) | 그래프 탐색 (Graph Traversal) |
| 강점 | 구체적인 팩트 찾기 | 복잡한 추론, 요약 |
| 정보 연결성 | 낮음 (단절된 정보 조각) | 높음 (정보 간의 맥락 파악) |
| 구축 비용 | 비교적 낮음 | 높음 (그래프 설계 및 추출 과정 필요) |
# 네이티브 클라우드
## 정의
단순히 on-premise에 있던 걸 클라우드로 옮기는 것이 아닌, 처음부터 클라우드환경에 최적화된 구조로 설계하는 것을 의미.  
CNCF(Cloud Native Computing Foundation)에서는 이를 통해 조직이 퍼블릭, 프라이빗, 하이브라드 클라우드 환경에서 확장성 있는 애플리케이션을 만들 수 있다고 정의.
> 클라우드의 장점을 최대한 활용하여 애플리케이션을 구축하고 실행하는 방식  
## 핵심 4대 요소
### 1. 컨테이너 (Containers)
**개념**: 애플리케이션과 실행에 필요한 앱을 작은 기능 단위로 쪼개서 개발하는 것  
**장점**: 가볍고, 어디서든 똑같이 실행됨
### 2. 마이크로서비스 (Microservies)
**개념**: 거대한 하나의 앱을 작은 기능 단위로 쪼개서 개발하는 것.  
**장점**: '결제' 기능이 터져도 '상품조회' 기능은 살아있을 수 있어 부분 수정과 배포가 빨라짐
### 3. DevOps & CI/CD (지속적 통합/배포)
**개념**: 개발과 운영의 경계를 없애고, 코드 작성부터 배포까지 과정을 자동화하는 파이프라인  
**장점** 하루에도 수십 번씩 업데이트가 가능해져 고객 피드백을 바로 반영할 수 있음
### 4. 서비스 메시 (Service Mesh)
**개념**: 쪼개진 수많은 마이크로서비스들 간의 통신을 담당하는 인프라 계층
**장점**: 서비스 간의 연결을 안전하고 효율적으로 관리해 줌
## 3. 기존방식(Monolith) vs 클라우드 네이티브
| 구분 | 기존방식 | 클라우드 네이티브 |
|------|------|------|
| 구조 | 거대한 단일 애플리케이션 | 독립적인 마이크로서비스들의 집합 |
| 배포 | 전체 시스템 중단 후 배포 (무거움) | 서비스별 무중단/개별 배포 (가벼움) |
| 확장성 | Scale-up (서버 성능 자체를 높임) | Scale-out (서버 개수를 늘림, 유연함) |
| 장애 영향 | 하나가 죽으면 전체 시스템 다운 위험 | 특정 기능만 장애, 전체는 유지개발 |
| 주기 | 긺 (몇 달에 한 번) | 매우 짧음 (수시 배포)|
## 4. 장점
**민첩성(Agility)**: 시장 변화에 맞춰 기능을 빨리 만들고 고칠 수 있음
**확장서(Scalability)**: 사용자가 갑자기 몰리면(트래픽 폭주) 자동으로 서버를 늘려서 대응 가능
**회복성(Resiliency)**: 시스템 일부가 망가져도 전체 서비스는 죽지 않고 스스로 복구 가능